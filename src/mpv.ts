import { ChildProcess, spawn } from 'child_process'
import EventEmitter from 'events'
import fs from 'fs'
import net from 'net'
import path from 'path'

const BIN_DIR = `bin`
const MPV_EXE = `mpv.exe`

/** Property name for the current played file, without path */
const PROP_FILE = 'filename'
/** Property name for the full path of the current file */
const PROP_PATH = 'path'
/** Property name for the length of the current file in bytes */
const PROP_SIZE = 'file-size'
/** Property name for the title tag for the current file, or `filename` */
const PROP_TITLE = 'media-title'
/** Property name for the duration of the file in seconds */
const PROP_DURATION = 'duration'
/** Property name for the playback position in seconds, clamped */
const PROP_POSITION = 'playback-time'
/** Property name for the current subtitle text */
const PROP_SUB_TEXT = 'sub-text'
/** Property name for the current subtitle start time in seconds */
const PROP_SUB_START = 'sub-start'
/** Property name for the current subtitle end time in seconds */
const PROP_SUB_END = 'sub-end'
/** Property name for the first looping point */
const PROP_AB_LOOP_A = 'ab-loop-a'
/** Property name for the second looping point */
const PROP_AB_LOOP_B = 'ab-loop-b'
/** Property name for the paused state */
const PROP_PAUSED = 'pause'

// Find the `mpv.exe` executable
const mpv_path = (() => {
	let base = path.normalize(path.dirname(__filename))
	while (base) {
		const mpv_path = path.join(base, BIN_DIR, MPV_EXE)
		try {
			const mpv_stat = fs.statSync(mpv_path)
			if (mpv_stat.isFile()) {
				return mpv_path
			}
		} catch (e) {
			// ignore error
		}
		const parent = path.normalize(path.join(base, '..'))
		if (parent != base) {
			base = parent
		} else {
			break
		}
	}
	return ''
})()

if (mpv_path) {
	console.log(`Found player at ${mpv_path}`)
} else {
	console.error(`Could not find mpv player, aborting`)
	console.error(`Expected '${path.join(BIN_DIR, MPV_EXE)}' in the script directory or parent directories`)
	console.error(``)
	process.exit(1)
}

const IPC_PIPE = 'mpv-kotoba-control'

interface EventsForMPV {
	/** The connection to the IPC instance has been established. */
	connect: () => void

	/** The connection to the IPC instance has been closed or lost. */
	disconnect: () => void

	/** Event generated for each line in the standard output. */
	output: (line: string) => void

	/** Event generated for each line in the error output and other generic errors. */
	error: (reason: string, error?: Error) => void

	/** Event generated for each log line generated by the player. */
	log: (args: { text: string; level: string; prefix: string }) => void

	/** Event generated for any IPC message received. */
	ipc: (data: { [key: string]: unknown }) => void

	/** Event generated whatever the current playback state is changed. */
	playback: (info?: PlaybackInfo) => void
}

/** A single subtitle line. */
export type Subtitle = {
	text: string
	start: number
	end: number
}

type PartialSubtitle = {
	text?: string
	start?: number
	end?: number
}

/** Playback info for the current file. */
export type PlaybackInfo = {
	file_name?: string
	file_path?: string
	file_size?: number
	title?: string
	paused?: boolean
	position?: number
	duration?: number
	subtitle?: Subtitle
	loop_a?: number
	loop_b?: number
}

export interface MPV {
	on<K extends keyof EventsForMPV>(event: K, listener: EventsForMPV[K]): this

	emit<K extends keyof EventsForMPV>(event: K, ...args: Parameters<EventsForMPV[K]>): boolean
}

/**
 * Wraps and controls an instance of the MPV video player.
 */
export class MPV extends EventEmitter {
	static _main: MPV

	private constructor() {
		super()
	}

	static get() {
		if (!MPV._main) {
			MPV._main = new MPV()
		}
		return MPV._main
	}

	/** Returns if the MPV player instance is open and connected. */
	get is_connected() {
		return this._connected
	}

	/** Returns playback information if the player is connected. */
	get playback() {
		return this._playback ? { ...this._playback } : undefined
	}

	/** Opens the MPV player instance if not open. */
	open() {
		this.try_spawn()
	}

	/**
	 * Opens the MPV player instance if not open, and optionally loads the given
	 * file.
	 */
	open_file(filename: string, { paused = false } = {}) {
		this.open()
		if (filename) {
			this.queue(() => this.load_file(filename, { paused }))
		}
	}

	/**
	 * Closes the player if open.
	 */
	close() {
		this.send_command('quit')
	}

	/**
	 * Load a file replacing the current one.
	 */
	load_file(filename: string, { paused = false } = {}) {
		this.send_command('loadfile', filename)
		if (paused) {
			this.set_property('pause', true)
		}
	}

	/**
	 * Sets a property.
	 */
	set_property(name: string, value: unknown) {
		this.send_command('set', name, value)
	}

	/**
	 * Add a value to a property.
	 */
	add_property(name: string, value = 1) {
		this.send_command('add', name, value)
	}

	/**
	 * Cycles a property value
	 */
	cycle_property(name: string, value?: 'up' | 'down') {
		if (value) {
			this.send_command('cycle', name, value)
		} else {
			this.send_command('cycle', name)
		}
	}

	/**
	 * Queue a command to execute once an IPC connection has been established.
	 */
	queue(fn: () => void) {
		process.nextTick(() => {
			if (this.is_connected) {
				fn()
			} else {
				this._command_queue.push(fn)
			}
		})
	}

	/**
	 * Sends a raw command to the instance. If the instance is not connected,
	 * this will do nothing.
	 *
	 * Returns the `request_id` for the command, which is included in the
	 * response.
	 */
	public send_command(name: string, ...args: unknown[]) {
		return this.do_send_command(name, false, ...args)
	}

	/**
	 * Same as `send_command` but sends the command asynchronously.
	 */
	public send_command_async(name: string, ...args: unknown[]) {
		return this.do_send_command(name, true, ...args)
	}

	_observe_id = 0
	_observers: { [key: string]: { id: number; count: number } } = {}

	/**
	 * Sends a command to the player to observe the given property. This will
	 * generate events whenever the property is changed.
	 *
	 * Returns a function that when called will remove the observer.
	 */
	public observe_property(name: string) {
		let observer = this._observers[name]
		if (observer) {
			observer.count++
		} else {
			observer = { id: ++this._observe_id, count: 1 }
			this._observers[name] = observer
		}
		this.send_command('observe_property', observer.id, name)
		return () => {
			observer.count--
			if (observer.count == 0) {
				this.send_command('unobserve_property', observer.id)
				delete this._observers[name]
			}
		}
	}

	//========================================================================//
	// Private implementation
	//========================================================================//

	_playback?: PlaybackInfo
	_subtitle?: PartialSubtitle

	_process?: ChildProcess
	_socket?: net.Socket

	_connected = false

	// Holds commands to execute as soon as an IPC connection is established.
	_command_queue: Array<() => void> = []

	/** Resets all variables to their defaults on closing. */
	private on_close() {
		const ps = this._process

		this._playback = undefined
		this._subtitle = undefined
		this.emit('playback')

		if (this._connected) {
			this._connected = false
			this.emit('disconnect')
		}
		this._process = undefined
		this._socket = undefined
		this._command_queue.length = 0

		// Make sure the MPV process does not stay around
		if (ps) {
			const id = setTimeout(() => {
				ps.kill()
			}, 5000)
			ps.on('close', () => clearTimeout(id))
		}
	}

	/**
	 * Spawns the MPV process if not open already.
	 */
	private try_spawn() {
		if (!this._process) {
			const ps = spawn(mpv_path, [
				'--quiet',
				'--idle=yes',
				'--ontop', //spell-checker: ignore ontop
				'--keep-open=yes',
				'--force-window=yes',
				'--no-resume-playback',
				`--input-ipc-server=${IPC_PIPE}`,
			])
			this._process = ps

			const interval = setInterval(() => this.try_connect(), 500)

			type Data = { toString(): string }
			ps.stdout.on('data', (data: Data) => this.on_output(false, data.toString()))
			ps.stderr.on('data', (data: Data) => this.on_output(true, data.toString()))
			ps.on('exit', (code) => {
				clearInterval(interval)
				if (this._process == ps) {
					this.on_close()
				}
				if (code) {
					this.emit('error', `a player instance exited with code ${code}`)
				}
			})

			setTimeout(() => this.try_connect(), 20)
		}
	}

	/**
	 * Try to connect to the MPV instance by IPC.
	 */
	private try_connect() {
		if (this._socket || !this._process) {
			return
		}
		try {
			const socket = net.connect(`\\\\.\\pipe\\${IPC_PIPE}`)
			this._socket = socket

			socket.on('connect', () => {
				if (this._socket === socket) {
					this._connected = true
					this.do_init()
					this.emit('connect')
				}
			})

			socket.on('close', () => {
				if (this._socket === socket) {
					this.on_close()
				}
			})

			socket.on('error', (err) => {
				if (this._connected && this._socket === socket) {
					this.emit('error', 'socket error', err)
				} else if (this._socket === socket) {
					// this is a failed attempt
					this._socket = undefined
				}
			})

			let buffer = ''
			socket.on('data', (data) => {
				if (this._socket !== socket) {
					return
				}
				buffer += data.toString()
				for (let p = buffer.indexOf('\n'); p >= 0; p = buffer.indexOf('\n')) {
					const line = buffer.slice(0, p)
					buffer = buffer.slice(p + 1)
					try {
						const response = JSON.parse(line) as { [key: string]: unknown }
						this.on_ipc(response)
					} catch (err) {
						this.emit('error', 'parsing IPC', err)
					}
				}
			})

			socket.on('end', () => {
				if (this._socket === socket) {
					this.on_close()
				}
			})
		} catch (err) {
			this.emit('error', 'connection attempt', err)
			// ignore attempt errors
		}
	}

	/** Called by try_connect if successful to initialize the player. */
	private do_init() {
		this._observers = {} // reset observer map

		this._playback = {}

		// enable log debug messages
		this.send_command('request_log_messages', 'debug')

		// watch main properties necessary for playback control
		;[
			PROP_FILE,
			PROP_PATH,
			PROP_SIZE,
			PROP_TITLE,
			PROP_DURATION,
			PROP_POSITION,
			PROP_SUB_TEXT,
			PROP_SUB_START,
			PROP_SUB_END,
			PROP_AB_LOOP_A,
			PROP_AB_LOOP_B,
			PROP_PAUSED,
		].forEach((prop) => this.observe_property(prop))

		// execute commands
		const queue = this._command_queue
		this._command_queue = []
		queue.forEach((fn) => fn())
	}

	_request_id = 0

	/** Sends a comment through IPC if connected. */
	private do_send_command(name: string, async: boolean, ...args: unknown[]) {
		const id = ++this._request_id
		const cmd = { command: [name, ...args], request_id: id, async }
		if (this._socket) {
			try {
				this._socket.write(JSON.stringify(cmd) + '\n')
			} catch (e) {
				this.emit('error', e)
			}
		}
		return id
	}

	/**
	 * Called whanever any data is received on the IPC channel with the decoded
	 * JSON data.
	 */
	private on_ipc(data: { [key: string]: unknown }) {
		this.emit('ipc', data)
		switch (data.event) {
			case 'log-message': {
				const entry = data as { prefix: string; level: string; text: string }
				entry.text = entry.text.replace(/\n$/, '')
				this.emit('log', entry)
				break
			}
			case 'property-change': {
				if (!this._playback) {
					break
				}
				const name = data.name as string
				const value = data.data

				let changed = true
				this._subtitle = this._subtitle || {}
				switch (name) {
					case PROP_FILE:
						this._playback.file_name = value ? (value as string) : undefined
						break
					case PROP_PATH:
						this._playback.file_path = value ? (value as string) : undefined
						break
					case PROP_SIZE:
						this._playback.file_size = value ? (value as number) : undefined
						break
					case PROP_TITLE:
						this._playback.file_size = value ? (value as number) : undefined
						break
					case PROP_DURATION:
						this._playback.duration = value ? (value as number) : undefined
						break
					case PROP_POSITION:
						this._playback.position = value ? (value as number) : undefined
						break
					case PROP_SUB_TEXT:
						this._subtitle.text = (value as string) || ''
						break
					case PROP_SUB_START:
						this._subtitle.start = (value as number) || undefined
						break
					case PROP_SUB_END:
						this._subtitle.end = (value as number) || undefined
						break
					case PROP_AB_LOOP_A:
						this._playback.loop_a = value && value != 'no' ? (value as number) : undefined
						break
					case PROP_AB_LOOP_B:
						this._playback.loop_b = value && value != 'no' ? (value as number) : undefined
						break
					case PROP_PAUSED:
						this._playback.paused = value ? (value as boolean) : undefined
						break
					default:
						changed = false
						break
				}
				if (changed) {
					const sub = this._subtitle
					if (sub && sub.text && sub.start != null && sub.end != null && sub.end > sub.start) {
						this._playback.subtitle = sub as Subtitle
					} else {
						this._playback.subtitle = undefined
					}

					const p = this._playback as { [key: string]: unknown }
					for (const k of Object.keys(p)) {
						if (p[k] === undefined) {
							delete p[k]
						}
					}
					process.nextTick(() => this.emit('playback', this._playback))
				}
				break
			}
		}
	}

	_stdout = { text: '' }
	_stderr = { text: '' }

	/** Parses MPV output and generate `output` and `error` events. */
	private on_output(err: boolean, data: string) {
		const out = err ? this._stderr : this._stdout
		out.text += data
		while (true) {
			const m = /[\n\r]/.exec(out.text)
			const pos = m ? m.index : -1
			if (pos >= 0) {
				const line = out.text.slice(0, pos)
				out.text = out.text.slice(pos + 1)
				if (line.trim()) {
					if (err) {
						this.emit('error', `stderr: ${line}`)
					} else {
						this.emit('output', line)
					}
				}
			} else {
				break
			}
		}
	}
}
